using CommandLine;
using Common.Security.Ciphers;
using System;
using Utility.Security.Options;

namespace Utility.Security
{
    internal static class Program
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="args"></param>
        public static void Main(string[] args)
        {
            try
            {
                // Parse the arguments and tranform them into the correct options object
                var options = Parser.Default.ParseArguments<EncryptOptions, DecryptOptions>(args);

                // TODO: We seem to have to take a return value from this
                options.MapResult(
                    (EncryptOptions opts) => Encrypt(opts),
                    (DecryptOptions opts) => Decrypt(opts),
                    _ => Error()
                );
            }
            catch (Exception ex)
            {
                DisplayOutput(ex.Message);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="result"></param>
        private static void DisplayOutput(string result)
        {
            Console.WriteLine($"{result}");
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="opts"></param>
        /// <returns></returns>
        private static string Encrypt(EncryptOptions opts)
        {
            var encryptedString = StringCipher.Encrypt(opts.PlainString, opts.PassPhrase);

            var result = $"Encrypted cipher [{encryptedString}] generated by encrypting plain string [{opts.PlainString}] with pass phrase [{opts.PassPhrase}]";

            DisplayOutput(result);

            return encryptedString;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="opts"></param>
        /// <returns></returns>
        private static string Decrypt(DecryptOptions opts)
        {
            var decryptedString = StringCipher.Decrypt(opts.CipherString, opts.PassPhrase);

            var result = $"Decrypted string [{decryptedString}] generated by decrypting cipher string [{opts.CipherString}] with pass phrase [{opts.PassPhrase}]";

            DisplayOutput(result);

            return decryptedString;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        private static string Error()
        {
            //TODO: Log this error somewhere

            return null;
        }

    }
}
